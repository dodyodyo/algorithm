"""
위상 정렬
개념: 사이클이 없는 방향 그래프의 모든 노드를 '방향성에 거스르지 않도록 순서대로 나열하는 것'
기능: 노드 간의 순서를 결정
특징: 사이클이 없어야함
시간복잡도: O(V + E) 노드 수: V, 에지 수: E

위상 정렬은 항상 유일한 값으로 정렬되지 않는다.
사이클이 존재하면 노드 간의 순서를 명확하게 정의할 수 없으므로 위상 정렬을 적용할 수 없다.
진입차수(indegree): 특정 노드에 대해서 다른 노드로부터 들어오는 간선의 개수

진입 차수 리스트와 정렬 리스트가 필요
개념
1. 진입 차수 리스트를 업데이트한다.
2. 진입 차수 리스트에서 진입 차수가 0인 노드를 선택하고 선택된 노드를 정렬 리스트에 저장한다.
그 후 인접 리스트에서 선택된 노드가 가리키는 노드들의 진입 차수를 1씩 뺀다.
3. 진입 차수 리스트의 모든 진입 차수가 0이 될때까지 반복

구현
1. 진입 차수가 0인 노드들을 모두 큐에 저장한다.
2 큐에서 데이터를 뽑아와서 해당 노드를 탐색 결과에 추가하고, 해당 노드가 가리키는 노드의 진입 차수를 1씩 감소한다.
3. 감소했을 때 진입 차수가 0이 되는 노드를 큐에 삽입한다.
4. 큐가 빌 때까지 1~3을 반복한다. 

"""

from collections import deque

# 노드의 개수와 간선의 개수를 입력받기
v, e = map(int, input().split())
# 모든 노드에 대한 진입차수는 0으로 초기화
indegree = [0] * (v + 1)
# 각 노드에 연결된 간선 정보를 담기 위한 연결 리스트 초기화
graph = [[] for _ in range(v + 1)]

# 방향 그래프의 모든 간선 정보를 입력받기
for _ in range(e):
    a, b = map(int, input().split())
    graph[a].append(b)  # 정점 A에서 B로 이동 가능
    # 진입차수를 1씩 증가
    indegree[b] += 1


# 위상 정렬 함수
def topology_sort():
    result = []  # 알고리즘 수행 결과를 담을 리스트
    q = deque()

    # 처음 시작할 때는 진입차수가 0인 노드를 큐에 삽입
    for i in range(1, v + 1):
        if indegree[i] == 0:
            q.append(i)

    # 큐가 빌때까지 반복
    while q:
        # 큐에서 원소를 꺼내기
        now = q.popleft()
        result.append(now)
        # 해당 원소와 연결된 노드들의 진입차수에서 1 빼기
        for next in graph[now]:
            indegree[next] -= 1
            # 새롭게 진입차수가 0이 되는 노드를 큐에 삽입
            if indegree[next] == 0:
                q.append(next)

    # 위상 정렬을 수행한 결과 출력
    for i in result:
        print(i, end=' ')


topology_sort()
